#!/bin/bash
#
# Copyright (c) 2017 Regents of The University of Michigan.
# All Rights Reserved.
#
# Author: Robert <heinro@med.umich.edu>
#

set -e
RESOURCE_DIR=$(dirname "$0")/../share/geo-omics-scripts

# shellcheck disable=SC2034
{
USAGE="[OPTIONS]..."
HELP="quality control for a sample's fastq files"
ARG_HELP="
  -f, --fwd             Fastq file with forward reads, default is fwd.fastq
  -r, --rev             Fastq file with reverse reads default is rev.fastq
      --final INFIX     Infix used for final output files.  Default is 'good'
      --clean-only      Delete previously created files and stop.
  -a, --adapters=FILE   Specifies the adapters file to be used.  By default a
                        file based on the Illumina adapter file TruSeq3-PE-2.fa
                        as distributed by the Trimmomatic project.
      --keep-all	Keep all intermediate files, by default some not-so-important
			intermediate results will be deleted to save disk space
      --no-dereplicate  Skip the de-replication step
      --no-fasta-interleave
                        Skip building the interleaved fasta file,
                        interleaved fastq will still be build.  This option is
                        redundant when --no-interleaved is used.
  -T, --trimmomatic     Use Trimmomatic for adapter and quality trimming.  By default
                        scythe ans sickle are used.
  -t N, --threads N, --cpus N
                        Number of parallel threads to employ (for Trimmomatic)
"
MORE_HELP="
qc implements the QC part of the Geomicro Illumina Reads Pipline.  At each
invocation qc will clean the directory of what the script thinks are previously
generated files.

qc is part of the omics(1) tool chain.
"
CHECK_PROGS="fastqc scythe sickle interleave"
SHORT_OPTIONS=a:,f:,r:,t:,T
LONG_OPTIONS=clean-only,adapters:,fwd:,rev:,final:,keep-all,no-dereplicate,no-fasta-interleave,trimmomatic,threads:,cpus:
}

handle_options () {
    if [ "$#" -gt 0 ]; then
	case "$1" in
	    (-f|--fwd)
		FWD_FASTQ=$2
		return 2;;
	    (-r|--rev)
		REV_FASTQ=$2
		return 2;;
	    (--final)
		FINAL=$2
		return 2;;
	    (-a|--adapters)
		ADAPTERS=$2
		return 2;;
	    (--clean-only)
	        CLEAN_ONLY=true
	        return 1;;
	    (--keep-all)
	        KEEPALL=true
	        return 1;;
	    (--no-dereplicate)
	        DEREPLICATION=false
	        return 1;;
	    (--no-fasta-interleave)
	        INTERLEAVE_FASTA=false
	        return 1;;
            (-T|--trimmomatic)
                TRIMMOMATIC=true
                return 1;;
            (-t|--threads|--cpus)
                CPUS=$2
                return 2;;
        esac
    else
        return 0
    fi
}

##########################
# default variable values
##########################

# Set adapter file depending on server (for scythe only)
ADAPTERS_DEBIAN=/usr/share/trimmomatic/TruSeq3-PE-2.fa
ADAPTERS_FLUX=/sw/lsa/centos7/trimmomatic/0.36/adapters/TruSeq3-PE-2.fa
ADAPTERS_VONDAMM=/opt/packages/Trimmomatic/0.32/adapters/TruSeq3-PE-2.fa

set_default_scythe_adapters () {
    while [ $# -gt 0 ] && [ ! -r "$1" ]; do
        shift
    done
    ADAPTERS_SCYTHE=$1
}
set_default_scythe_adapters $ADAPTERS_DEBIAN $ADAPTERS_FLUX $ADAPTERS_VONDAMM

ADAPTERS_TRIMMOMATIC=$RESOURCE_DIR/TruSeq3-PE-2+omics.fa

# default input files as produced by prep script
FWD_FASTQ=fwd.fastq
REV_FASTQ=rev.fastq
#
CLEAN_ONLY=false
# infix for final output files
FINAL=good
# Remove intermediate results by default
KEEPALL=false
#
DEREPLICATION=true
INTERLEAVE_FASTA=true
# Use sickle/scythe by default
TRIMMOMATIC=false
#
CPUS=2

# shellcheck source=../lib/liba.sh
# shellcheck disable=SC1091
. "$RESOURCE_DIR/liba.sh" || (echo "Failed to source script library"; exit 1)

info1 () { info "[$(basename "$PWD")] $1" ; }
warning1 () { warning "[$(basename "$PWD")] $1" ; }
error1 () { error "[$(basename "$PWD")] $1" ; }
abort1 () { abort "[$(basename "$PWD")] $1" ; }

# mangle verbosity args
[[ -v V ]] && if [[ -n "$V" ]]; then V=("$V"); else V=(); fi

if [[ ! -v ADAPTERS ]]; then
    if $TRIMMOMATIC; then
        ADAPTERS=$ADAPTERS_TRIMMOMATIC
    else
        ADAPTERS=$ADAPTERS_SCYTHE
    fi
fi

# handle non-option parameters
if [ "$#" -gt 0 ]; then
    abort1 "Unknown parameters: ${*}"
fi

#########################
# some input sanitation
#########################
[ -r "$ADAPTERS" ] || abort1 "Adapters file not found: $ADAPTERS"
[ "$VERBOSITY" -lt 2 ] || info1 "Using adapters file: $ADAPTERS"
[ -r "$FWD_FASTQ" ] || abort1 "Forward reads file not found: $FWD_FASTQ"
[ -r "$REV_FASTQ" ] || abort1 "Reverse reads file not found: $REV_FASTQ"

#################################
# do stuff
################################

# get root of input file names
fwd=$(basename "$FWD_FASTQ" .fastq)
rev=$(basename "$REV_FASTQ" .fastq)
[ "$fwd" != "$rev" ] || abort1 "Forward and reverse reads filenames are equal?"

clean_all () {
    clean_intermediates
    # clean final results
    $RM -rf -- FASTQC
    $RM -f -- {sfwd,srev}{.derep,}.scythe.fastq
    $RM -f -- {"$fwd","$rev"}{.derep,}.matches.fastq
    $RM -f -- {int,"$fwd","$rev"}."$FINAL".fast{a,q}
}

clean_intermediates () {
    # clean up intermediate results
    $RM -f -- {"$fwd","$rev"}.derep.fastq
    $RM -f -- {int,"$fwd","$rev"}{.derep,}.scythe{.sickle,}.fastq
}


clean_all
! $CLEAN_ONLY || exit 0

clean_up () {
    # kill background
    j_long=$(jobs -l)
    if [[ -n $j_long ]]; then
        warning1 "The QC pipeline did not finish properly"
        warning1 "Still running background processes will be terminated, see errors below:"
    fi
    for j in $(jobs -p); do
        error1 "Terminating $(echo "$j_long" | grep "$j")"
        kill -s 15 "$j"
    done
    # clean temp data
    [[ -v tmpd ]] || exit 0
    debug "$(ls -Rlrth "$tmpd")"
    rm -rf -- "$tmpd"
}
trap clean_up EXIT
tmpd=$(mktemp -d)
debug "Using temp dir: $tmpd"
mkdir "$tmpd"/fqc

$MKDIR -p FASTQC
info1 "Starting pre-QC fastqc..."
fastqc -o FASTQC -f fastq -t 2 "$FWD_FASTQ" "$REV_FASTQ" &> FASTQC/fastqc.log &

# basename for files
base=""

# trim_in is what derep puts out, input for trimming

if $DEREPLICATION; then
    info1 "Starting derep..."
    base=".derep"
    fwd_derep_out=$tmpd/$fwd$base.fastq
    rev_derep_out=$tmpd/$rev$base.fastq
    mkfifo "$fwd_derep_out" "$rev_derep_out"
    if $KEEPALL; then
        fwd_trim_in=$fwd_derep_out.copy
        rev_trim_in=$rev_derep_out.copy
        mkfifo "$fwd_trim_in" "$rev_trim_in"
        # shellcheck disable=SC2094
        tee "./$(basename "$fwd_derep_out")" < "$fwd_derep_out" > "$fwd_trim_in" &
        # shellcheck disable=SC2094
        tee "./$(basename "$rev_derep_out")" < "$rev_derep_out" > "$rev_trim_in" &
    else
        fwd_trim_in=$fwd_derep_out
        rev_trim_in=$rev_derep_out
    fi
    python3 -m omics.derep "${V[@]}" --check "$FWD_FASTQ" "$REV_FASTQ" --out-dir "$tmpd" &
else
    fwd_trim_in=$tmpd/$fwd$base.fastq
    rev_trim_in=$tmpd/$rev$base.fastq
fi

oldbase=$base
if $TRIMMOMATIC; then
    # Trimmomatic's makes the data streaming more complicated:  It's seems not
    # possible to use fifos as input and it produces four output files that we
    # need to post-process, however with --keep-all the trimmed files are saved
    # directly and then reused for post-processing, hopefully the page-cache
    # makes this efficient
    info1 "Start adapter + quality trimming..."
    base="${base}.trim"
    fwd_trim_s=$tmpd/$fwd$base.s.fastq
    rev_trim_s=$tmpd/$rev$base.s.fastq
    if $KEEPALL; then
        fwd_trim=$fwd$base.fastq
        rev_trim=$rev$base.fastq
    else
        fwd_trim=$tmpd/$fwd$base.tmp.fastq
        rev_trim=$tmpd/$rev$base.tmp.fastq
    fi
    post_trim=$tmpd/int$base.fastq
    mkfifo "$post_trim"
    {
        fwd_trim_in_tmp="$tmpd/$fwd$base.in_tmp.fastq"
        rev_trim_in_tmp="$tmpd/$rev$base.in_tmp.fastq"
        {
            # make input files real for Trimmomatic consumption
            cat "$fwd_trim_in" > "$fwd_trim_in_tmp" &
            cat "$rev_trim_in" > "$rev_trim_in_tmp" &
            wait
        }
        TrimmomaticPE \
            -threads "$CPUS" \
            "$fwd_trim_in_tmp" "$rev_trim_in_tmp" \
            "$fwd_trim" "$fwd_trim_s" "$rev_trim" "$rev_trim_s" \
            ILLUMINACLIP:"$ADAPTERS":2:30:10:1:true \
            LEADING:3 TRAILING:3 \
            SLIDINGWINDOW:4:20 \
            MINLEN:20

        # re-pair singles
        info1 "Re-pairing Trimmomatic output..."
        cat "$fwd_trim_s" >> "$fwd_trim"
        grep '^@' "$fwd_trim_s" | sed -r 's/ 1/ 2/; s/$/\nN\n+\n!/' >> "$rev_trim"
        cat "$rev_trim_s" >> "$rev_trim"
        grep '^@' "$rev_trim_s" | sed -r 's/ 2/ 1/; s/$/\nN\n+\n!/' >> "$fwd_trim"

        # interleave and re-establish piping
        info1 "Interleaving trimmed read pairs..."
        python3 -m omics.interleave "${V[@]}" "$fwd_trim" "$rev_trim" > "$post_trim"
    } &

else
    info1 "Start adapter trimming..."
    base="${base}.scythe"
    # scythe_out to be fed into interleaver
    fwd_scythe_out=$tmpd/$fwd$base.fastq
    rev_scythe_out=$tmpd/$rev$base.fastq
    mkfifo "$fwd_scythe_out" "$rev_scythe_out"
    scythe -a "$ADAPTERS" -q sanger -m "$fwd${oldbase}.matches.fastq" -o "$fwd_scythe_out" "$fwd_trim_in" &
    scythe -a "$ADAPTERS" -q sanger -m "$rev${oldbase}.matches.fastq" -o "$rev_scythe_out" "$rev_trim_in" &
    info1 "Start interleaving reads..."
    if $KEEPALL; then
        fwd_int_in=$tmpd/fwd.int_in.fastq
        rev_int_in=$tmpd/rev.int_in.fastq
        mkfifo "$fwd_int_in" "$rev_int_in"
        # shellcheck disable=SC2094
        tee "./$(basename "$fwd_scythe_out")" < "$fwd_scythe_out" > "$fwd_int_in" &
    base="${base}.sickle"
        # shellcheck disable=SC2094
        tee "./$(basename "$rev_scythe_out")" < "$rev_scythe_out" > "$rev_int_in" &
    else
        fwd_int_in=$fwd_scythe_out
        rev_int_in=$rev_scythe_out
    fi
    sickle_in=$tmpd/int$base.fastq
    mkfifo "$sickle_in"
    python3 -m omics.interleave "${V[@]}" "$fwd_int_in" "$rev_int_in" > "$sickle_in" &
    info1 "Start quality score trimming..."
    oldbase=$base
    base="${base}.sickle"
    post_trim=$tmpd/int$base.fastq
    mkfifo "$post_trim"
    sickle pe -t sanger -c "$sickle_in" -M "$post_trim" &
fi
# $KEEPALL || rm -f -- "int$oldbase.fastq"

oldbase=$base
base=".$FINAL"

if $INTERLEAVE_FASTA; then
    info1 "Start converting to fasta..."
    # copy post_trim
    post_trim_orig=$post_trim
    post_trim=$post_trim.copy
    q2a_in=$tmpd/q2a_in
    mkfifo "$post_trim" "$q2a_in"
    tee "$q2a_in" < "$post_trim_orig" > "$post_trim" &
    python3 -m omics.fastq2fasta "${V[@]}" < "$q2a_in" > "int$base.fasta" &
fi

info1 "Separating read directions again..."
fwd_sep_out=$tmpd/$fwd$oldbase.fastq
rev_sep_out=$tmpd/$rev$oldbase.fastq
sep_in=$tmpd/sep_in
int_final=int$base.fastq
mkfifo "$fwd_sep_out" "$rev_sep_out" "$sep_in"
tee "$sep_in" < "$post_trim" > "$int_final" &
separate-interleaved "${V[@]}" -f "$fwd_sep_out" -r "$rev_sep_out" "$sep_in" &

# copy separate output 
fwd_final=$fwd$base.fastq
rev_final=$rev$base.fastq
fwd_fastqc_2_in=$tmpd/fqc/$fwd$base.fastq
rev_fastqc_2_in=$tmpd/fqc/$rev$base.fastq
mkfifo "$fwd_fastqc_2_in" "$rev_fastqc_2_in"
tee "$fwd_fastqc_2_in" < "$fwd_sep_out" > "$fwd_final" &
tee "$rev_fastqc_2_in" < "$rev_sep_out" > "$rev_final" &
info1 "Starting post-QC fastqc run..."
fastqc -o FASTQC -f fastq -t 2 "$fwd_fastqc_2_in" "$rev_fastqc_2_in" &>> FASTQC/fastqc.log &
#wait %fastqc
#$INTERLEAVE_FASTA && wait %python3
#$KEEPALL || rm -f -- "$fwd$oldbase.fastq" "$rev$oldbase.fastq"
$KEEPALL || clean_intermediates

# map cmd-line sub-strings to job description
declare -A wait_list
wait_list=(
[ fastqc ]="FASTQC"
[omics.derep]="dereplication"
[ scythe ]="adapter trimming"
[omics.interleave]="interleaving"
[ sickle ]="quality trimming"
[omics.fastq2fasta]="converting to fasta format"
[separate-interleave]="separating read directions again"
)

# map PIDs to job wait list
declare -A pids
while read -r line; do
    pid=$(echo "$line" | sed -r 's/[ ]+/ /g' | cut -d' ' -f2)
    for i in "${!wait_list[@]}"; do
        if echo "$line" | grep -q "$i"; then
            pids["$pid"]="$i"
            break
        fi
    done
done < <(jobs -l)

# wait for jobs to finish
for p in $(echo "${!pids[@]}" | sed -r 's/ /\n/g' | sort -n); do
    if wait "$p"; then
       info1 "Done: ${wait_list[${pids[$p]}]}"
   else
       error1 "${wait_list[${pids[$p]}]}: exit status $?, PID: $pid"
   fi
done

info1 "All done!"


# gmb: input: fwd.fastq
# gmb: input: rev.fastq
# gmb: output: good_int.fasta
# gmb: cpus: 2
