#!/bin/bash
#
# Copyright (c) 2017 Regents of The University of Michigan.
# All Rights Reserved.
#
# Author: Robert <heinro@med.umich.edu>
#

set -e
# shellcheck disable=SC2034
{
USAGE="[OPTIONS]..."
HELP="quality control for a sample's fastq files"
ARG_HELP="
  -f, --fwd             Fastq file with forward reads, default is fwd.fastq
  -r, --rev             Fastq file with reverse reads default is rev.fastq
      --final INFIX     Infix used for final output files.  Default is 'good'
      --clean-only      Delete previously created files and stop.
  -a, --adapters=FILE   Specifies the adapters file to be used.  By default the
                        Illumina adapter file TruSeq3-PE-2.fa as distributed by
			the Trimmomatic project will be used.
      --keep-all	Keep all intermediate files, by default some not-so-important
			intermediate results will be deleted to save disk space
      --less-mem        Use less memory during de-replication at the expense of
                        computing time

      --no-dereplicate  Skip the de-replication step
      --no-fasta-interleave
                        Skip building the interleaved fasta file,
                        interleaved fastq will still be build.  This option is
                        redundant when --no-interleaved is used.
"
MORE_HELP="
qc implements the QC part of the Geomicro Illumina Reads Pipline.  At each
invocation qc will clean the directory of what the script thinks are previously
generated files.

qc is part of the omics(1) tool chain.
"
CHECK_PROGS="fastqc scythe sickle interleave"
SHORT_OPTIONS=a:,f:,r:
LONG_OPTIONS=clean-only,adapters:,fwd:,rev:,final:,high-mem,keep-all,no-dereplicate,no-fasta-interleave
}

handle_options () {
    if [ "$#" -gt 0 ]; then
	case "$1" in
	    (-f|--fwd)
		FWD_FASTQ=$2
		return 2;;
	    (-r|--rev)
		REV_FASTQ=$2
		return 2;;
	    (--final)
		FINAL=$2
		return 2;;
	    (-a|--adapters)
		ADAPTERS=$2
		return 2;;
	    (--clean-only)
	        CLEAN_ONLY=true
	        return 1;;
            (--high-mem)
                LOW_MEM=false
                return 1;;
	    (--keep-all)
	        KEEPALL=true
	        return 1;;
	    (--no-dereplicate)
	        DEREPLICATION=false
	        return 1;;
	    (--no-fasta-interleave)
	        INTERLEAVE_FASTA=false
	        return 1;;
        esac
    else
        return 0
    fi
}

##########################
# default variable values
##########################

# Set adapter file depending on server
ADAPTERS_DEBIAN=/usr/share/trimmomatic/TruSeq3-PE-2.fa
ADAPTERS_FLUX=/sw/lsa/centos7/trimmomatic/0.36/adapters/TruSeq3-PE-2.fa
ADAPTERS_VONDAMM=/opt/packages/Trimmomatic/0.32/adapters/TruSeq3-PE-2.fa

set_default_adapters () {
    while [ $# -gt 0 ] && [ ! -r "$1" ]; do
        shift
    done
    ADAPTERS=$1
}
set_default_adapters $ADAPTERS_DEBIAN $ADAPTERS_FLUX $ADAPTERS_VONDAMM

# default input files as produced by prep script
FWD_FASTQ=fwd.fastq
REV_FASTQ=rev.fastq
#
CLEAN_ONLY=false
# infix for final output files
FINAL=good
# accommodate low memory, laptops etc by default
LOW_MEM=true
# Remove intermediate results by default
KEEPALL=false
#
DEREPLICATION=true
INTERLEAVE_FASTA=true

# shellcheck source=../lib/liba.sh
# shellcheck disable=SC1091
. "$(dirname "$0")/../share/geo-omics-scripts/liba.sh" || (echo "Failed to source script library"; exit 1)

info1 () { info "[$(basename "$PWD")] $1" ; }
abort1 () { abort "[$(basename "$PWD")] $1" ; }

# mangle verbosity args
[[ -v V ]] && if [[ -n "$V" ]]; then V=("$V"); else V=(); fi

# handle non-option parameters
if [ "$#" -gt 0 ]; then
    abort1 "Unknown parameters: ${*}"
fi

#########################
# some input sanitation
#########################
[ -r "$ADAPTERS" ] || abort1 "Adapters file not found: $ADAPTERS"
[ "$VERBOSITY" -lt 2 ] || info1 "Using adapters file: $ADAPTERS"
[ -r "$FWD_FASTQ" ] || abort1 "Forward reads file not found: $FWD_FASTQ"
[ -r "$REV_FASTQ" ] || abort1 "Reverse reads file not found: $REV_FASTQ"

#################################
# do stuff
################################

# get root of input file names
fwd=$(basename "$FWD_FASTQ" .fastq)
rev=$(basename "$REV_FASTQ" .fastq)
[ "$fwd" != "$rev" ] || abort1 "Forward and reverse reads filenames are equal?"

clean_all () {
    clean_intermediates
    # clean final results
    $RM -rf -- FASTQC
    $RM -f -- {sfwd,srev}{.derep,}.scythe.fastq
    $RM -f -- {"$fwd","$rev"}{.derep,}.matches.fastq
    $RM -f -- {int,"$fwd","$rev"}."$FINAL".fast{a,q}
}

clean_intermediates () {
    # clean up intermediate results
    $RM -f -- {"$fwd","$rev"}.derep.fastq
    $RM -f -- {int,"$fwd","$rev"}{.derep,}.scythe{.sickle,}.fastq
}


clean_all
! $CLEAN_ONLY || exit 0

clean_tmp () {
    [[ -v tmpd ]] || exit 0
    debug "$(ls -Rlrth "$tmpd")"
    rm -rf -- "$tmpd"
}
trap clean_tmp EXIT
tmpd=$(mktemp -d --tmpdir=/dev/shm)
debug "Using temp dir: $tmpd"
mkdir "$tmpd"/fqc

if $DEREPLICATION && $LOW_MEM; then
    # low-mem with derep: read input twice, straight from source
    fwd_fastqc_1_in=$FWD_FASTQ
    fwd_derep_in=$FWD_FASTQ
    rev_fastqc_1_in=$REV_FASTQ
    rev_derep_in=$REV_FASTQ
else
    # use named pipes for all except input for derep
    info1 "Reading fastq data into memory..."
    fwd_fastqc_1_in=$tmpd/fqc/$fwd.fastq
    rev_fastqc_1_in=$tmpd/fqc/$rev.fastq
    fwd_derep_in=$tmpd/$fwd.fastq
    rev_derep_in=$tmpd/$rev.fastq
    mkfifo "$fwd_fastqc_1_in" "$rev_fastqc_1_in"
    # derep needs seekable files, so skip mkfifo
    $DEREPLICATION || mkfifo "$fwd_derep_in" "$rev_derep_in"
    tee "$fwd_derep_in" < "$FWD_FASTQ" > "$fwd_fastqc_1_in" &
    tee "$rev_derep_in" < "$REV_FASTQ" > "$rev_fastqc_1_in" &
    tee_jobs=($(jobs -p))
fi

$MKDIR -p FASTQC
info1 "Starting pre-QC fastqc..."
fastqc -o FASTQC -f fastq -t 2 "$fwd_fastqc_1_in" "$rev_fastqc_1_in" &> FASTQC/fastqc.log &

# basename for files
if $DEREPLICATION; then
    base=".derep"
else
    base=""
fi

# scythe_in is what derep puts out
fwd_scythe_in=$tmpd/$fwd$base.fastq
rev_scythe_in=$tmpd/$rev$base.fastq

if $DEREPLICATION; then
    # derep needs a seekable file, so wait for copying to be done
    wait "${tee_jobs[@]}"
    info1 "Starting derep..."
    mkfifo "$fwd_scythe_in" "$rev_scythe_in"
    python3 -m omics.derep "${V[@]}" --check "$fwd_derep_in" "$rev_derep_in" --out-dir "$tmpd" &
fi

info1 "Start adapter trimming..."
oldbase=$base
base="${base}.scythe"
# scythe_out to be fed into interleaver
fwd_scythe_out=$tmpd/$fwd$base.fastq
rev_scythe_out=$tmpd/$rev$base.fastq
mkfifo "$fwd_scythe_out" "$rev_scythe_out"
scythe -a "$ADAPTERS" -q sanger -m "$fwd${oldbase}.matches.fastq" -o "$fwd_scythe_out" "$fwd_scythe_in" &
scythe -a "$ADAPTERS" -q sanger -m "$rev${oldbase}.matches.fastq" -o "$rev_scythe_out" "$rev_scythe_in" &
# ! $DEREPLICATION || $KEEPALL || rm -f -- "$fwd$oldbase.fastq" "$rev$oldbase.fastq"
info1 "Start interleaving reads..."
sickle_in=$tmpd/int$base.fastq
mkfifo "$sickle_in"
python3 -m omics.interleave "${V[@]}" "$fwd_scythe_out" "$rev_scythe_out" > "$sickle_in" &
info1 "Start quality score trimming..."
oldbase=$base
base="${base}.sickle"
sickle_out=$tmpd/int$base.fastq
mkfifo "$sickle_out"
sickle pe -t sanger -c "$sickle_in" -M "$sickle_out" &
# $KEEPALL || rm -f -- "int$oldbase.fastq"

oldbase=$base
base=".$FINAL"

if $INTERLEAVE_FASTA; then
    info1 "Start converting to fasta..."
    # copy sickle_out
    sickle_out_orig=$sickle_out
    sickle_out=$sickle_out.copy
    q2a_in=$tmpd/q2a_in
    #mkfifo "$sickle_out" "$q2a_in"
    #mkfifo "$q2a_in"
    tee "$q2a_in" < "$sickle_out_orig" > "$sickle_out" 
    python3 -m omics.fastq2fasta "${V[@]}" < "$q2a_in" > "int$base.fasta" &
fi

info1 "Separating read directions again..."
fwd_sep_out=$tmpd/$fwd$oldbase.fastq
rev_sep_out=$tmpd/$rev$oldbase.fastq
sep_in=$tmpd/sep_in
int_final=int$base.fastq
mkfifo "$fwd_sep_out" "$rev_sep_out" "$sep_in"
tee "$sep_in" < "$sickle_out" > "$int_final" &
separate-interleaved "${V[@]}" -f "$fwd_sep_out" -r "$rev_sep_out" "$sep_in" &

# copy separate output 
fwd_final=$fwd$base.fastq
rev_final=$rev$base.fastq
fwd_fastqc_2_in=$tmpd/fqc/$fwd$base.fastq
rev_fastqc_2_in=$tmpd/fqc/$rev$base.fastq
#mkfifo "$fwd_fastqc_2_in" "$rev_fastqc_2_in"
tee "$fwd_fastqc_2_in" < "$fwd_sep_out" > "$fwd_final" &
tee "$rev_fastqc_2_in" < "$rev_sep_out" > "$rev_final" &
info1 "Starting post-QC fastqc run..."
fastqc -o FASTQC -f fastq -t 2 "$fwd_fastqc_2_in" "$rev_fastqc_2_in" &>> FASTQC/fastqc.log &
#wait %fastqc
#$INTERLEAVE_FASTA && wait %python3
#$KEEPALL || rm -f -- "$fwd$oldbase.fastq" "$rev$oldbase.fastq"
$KEEPALL || clean_intermediates
wait
info1 "Done!"


# gmb: input: fwd.fastq
# gmb: input: rev.fastq
# gmb: output: good_int.fasta
# gmb: cpus: 2
