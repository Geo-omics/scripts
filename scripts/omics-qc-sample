#!/bin/bash
#
# Copyright (c) 2017 Regents of The University of Michigan.
# All Rights Reserved.
#
# Author: Robert <heinro@med.umich.edu>
#

set -e
# shellcheck disable=SC2034
{
USAGE="[OPTIONS]..."
HELP="quality control for a sample's fastq files"
ARG_HELP="
  -f, --fwd             Fastq file with forward reads, default is fwd.fastq
  -r, --rev             Fastq file with reverse reads default is rev.fastq
      --final INFIX     Infix used for final output files.  Default is 'good'
      --clean-only      Delete previously created files and stop.
  -a, --adapters=FILE   Specifies the adapters file to be used.  By default the
                        Illumina adapter file TruSeq3-PE-2.fa as distributed by
			the Trimmomatic project will be used.
      --keep-all	Keep all intermediate files, by default some not-so-important
			intermediate results will be deleted to save disk space
      --less-mem        Use less memory during de-replication at the expense of
                        computing time

      --no-dereplicate  Skip the de-replication step
      --no-fasta-interleave
                        Skip building the interleaved fasta file,
                        interleaved fastq will still be build.  This option is
                        redundant when --no-interleaved is used.
"
MORE_HELP="
qc implements the QC part of the Geomicro Illumina Reads Pipline.  At each
invocation qc will clean the directory of what the script thinks are previously
generated files.

qc is part of the omics(1) tool chain.
"
CHECK_PROGS="fastqc scythe sickle interleave"
SHORT_OPTIONS=a:,f:,r:
LONG_OPTIONS=clean-only,adapters:,fwd:,rev:,final:,high-mem,keep-all,no-dereplicate,no-fasta-interleave
}

handle_options () {
    if [ "$#" -gt 0 ]; then
	case "$1" in
	    (-f|--fwd)
		FWD_FASTQ=$2
		return 2;;
	    (-r|--rev)
		REV_FASTQ=$2
		return 2;;
	    (--final)
		FINAL=$2
		return 2;;
	    (-a|--adapters)
		ADAPTERS=$2
		return 2;;
	    (--clean-only)
	        CLEAN_ONLY=true
	        return 1;;
            (--high-mem)
                LOW_MEM=false
                return 1;;
	    (--keep-all)
	        KEEPALL=true
	        return 1;;
	    (--no-dereplicate)
	        DEREPLICATION=false
	        return 1;;
	    (--no-fasta-interleave)
	        INTERLEAVE_FASTA=false
	        return 1;;
        esac
    else
        return 0
    fi
}

##########################
# default variable values
##########################

# Set adapter file depending on server
ADAPTERS_DEBIAN=/usr/share/trimmomatic/TruSeq3-PE-2.fa
ADAPTERS_FLUX=/sw/lsa/centos7/trimmomatic/0.36/adapters/TruSeq3-PE-2.fa
ADAPTERS_VONDAMM=/opt/packages/Trimmomatic/0.32/adapters/TruSeq3-PE-2.fa

set_default_adapters () {
    while [ $# -gt 0 ] && [ ! -r "$1" ]; do
        shift
    done
    ADAPTERS=$1
}
set_default_adapters $ADAPTERS_DEBIAN $ADAPTERS_FLUX $ADAPTERS_VONDAMM

# default input files as produced by prep script
FWD_FASTQ=fwd.fastq
REV_FASTQ=rev.fastq
#
CLEAN_ONLY=false
# infix for final output files
FINAL=good
# accommodate low memory, laptops etc by default
LOW_MEM=true
# Remove intermediate results by default
KEEPALL=false
#
DEREPLICATION=true
INTERLEAVE_FASTA=true

# shellcheck source=../lib/liba.sh
# shellcheck disable=SC1091
. "$(dirname "$0")/../share/geo-omics-scripts/liba.sh" || (echo "Failed to source script library"; exit 1)

info1 () { info "[$(basename "$PWD")] $1" ; }
abort1 () { abort "[$(basename "$PWD")] $1" ; }

# mangle verbosity args
[[ -v V ]] && if [[ -n "$V" ]]; then V=("$V"); else V=(); fi

# handle non-option parameters
if [ "$#" -gt 0 ]; then
    abort1 "Unknown parameters: ${*}"
fi

#########################
# some input sanitation
#########################
[ -r "$ADAPTERS" ] || abort1 "Adapters file not found: $ADAPTERS"
[ "$VERBOSITY" -lt 2 ] || info1 "Using adapters file: $ADAPTERS"
[ -r "$FWD_FASTQ" ] || abort1 "Forward reads file not found: $FWD_FASTQ"
[ -r "$REV_FASTQ" ] || abort1 "Reverse reads file not found: $REV_FASTQ"

#################################
# do stuff
################################

# get root of input file names
fwd=$(basename "$FWD_FASTQ" .fastq)
rev=$(basename "$REV_FASTQ" .fastq)
[ "$fwd" != "$rev" ] || abort1 "Forward and reverse reads filenames are equal?"

clean_all () {
    clean_intermediates
    # clean final results
    $RM -rf -- FASTQC
    $RM -f -- {sfwd,srev}{.derep,}.scythe.fastq
    $RM -f -- {"$fwd","$rev"}{.derep,}.matches.fastq
    $RM -f -- {int,"$fwd","$rev"}."$FINAL".fast{a,q}
}

clean_intermediates () {
    # clean up intermediate results
    $RM -f -- {"$fwd","$rev"}.derep.fastq
    $RM -f -- {int,"$fwd","$rev"}{.derep,}.scythe{.sickle,}.fastq
}


clean_all
! $CLEAN_ONLY || exit 0

clean_up () {
    # kill background
    j_long=$(jobs -l)
    if [[ -n $j_long ]]; then
        warning "The QC pipeline did not finish properly"
        warning "Still running background processes will be terminated, see errors below:"
    fi
    for j in $(jobs -p); do
        error "Terminating $(echo "$j_long" | grep "$j")"
        kill -s 15 "$j"
    done
    # clean temp data
    [[ -v tmpd ]] || exit 0
    debug "$(ls -Rlrth "$tmpd")"
    rm -rf -- "$tmpd"
}
trap clean_up EXIT
tmpd=$(mktemp -d --tmpdir=/dev/shm)
debug "Using temp dir: $tmpd"
mkdir "$tmpd"/fqc

if $DEREPLICATION && $LOW_MEM; then
    # low-mem with derep: read input twice, straight from source
    fwd_fastqc_1_in=$FWD_FASTQ
    fwd_derep_in=$FWD_FASTQ
    rev_fastqc_1_in=$REV_FASTQ
    rev_derep_in=$REV_FASTQ
else
    # use named pipes for all except input for derep
    info1 "Reading fastq data into memory..."
    fwd_fastqc_1_in=$tmpd/fqc/$fwd.fastq
    rev_fastqc_1_in=$tmpd/fqc/$rev.fastq
    fwd_derep_in=$tmpd/$fwd.fastq
    rev_derep_in=$tmpd/$rev.fastq
    mkfifo "$fwd_fastqc_1_in" "$rev_fastqc_1_in"
    # derep needs seekable files, so skip mkfifo
    $DEREPLICATION || mkfifo "$fwd_derep_in" "$rev_derep_in"
    tee "$fwd_derep_in" < "$FWD_FASTQ" > "$fwd_fastqc_1_in" &
    tee "$rev_derep_in" < "$REV_FASTQ" > "$rev_fastqc_1_in" &
    tee_jobs=($(jobs -p))
fi

$MKDIR -p FASTQC
info1 "Starting pre-QC fastqc..."
fastqc -o FASTQC -f fastq -t 2 "$fwd_fastqc_1_in" "$rev_fastqc_1_in" &> FASTQC/fastqc.log &

# basename for files
base=""

# scythe_in is what derep puts out

if $DEREPLICATION; then
    # derep needs a seekable file, so wait for copying to be done
    wait "${tee_jobs[@]}"
    info1 "Starting derep..."
    base=".derep"
    fwd_derep_out=$tmpd/$fwd$base.fastq
    rev_derep_out=$tmpd/$rev$base.fastq
    mkfifo "$fwd_derep_out" "$rev_derep_out"
    if $KEEPALL; then
        fwd_scythe_in=$fwd_derep_out.copy
        rev_scythe_in=$rev_derep_out.copy
        mkfifo "$fwd_scythe_in" "$rev_scythe_in"
        # shellcheck disable=SC2094
        tee "./$(basename "$fwd_derep_out")" < "$fwd_derep_out" > "$fwd_scythe_in" &
        # shellcheck disable=SC2094
        tee "./$(basename "$rev_derep_out")" < "$rev_derep_out" > "$rev_scythe_in" &
    else
        fwd_scythe_in=$fwd_derep_out
        rev_scythe_in=$rev_derep_out
    fi
    python3 -m omics.derep "${V[@]}" --check "$fwd_derep_in" "$rev_derep_in" --out-dir "$tmpd" &
else
    fwd_scythe_in=$tmpd/$fwd$base.fastq
    rev_scythe_in=$tmpd/$rev$base.fastq
fi

info1 "Start adapter trimming..."
oldbase=$base
base="${base}.scythe"
# scythe_out to be fed into interleaver
fwd_scythe_out=$tmpd/$fwd$base.fastq
rev_scythe_out=$tmpd/$rev$base.fastq
mkfifo "$fwd_scythe_out" "$rev_scythe_out"
scythe -a "$ADAPTERS" -q sanger -m "$fwd${oldbase}.matches.fastq" -o "$fwd_scythe_out" "$fwd_scythe_in" &
scythe -a "$ADAPTERS" -q sanger -m "$rev${oldbase}.matches.fastq" -o "$rev_scythe_out" "$rev_scythe_in" &
info1 "Start interleaving reads..."
if $KEEPALL; then
    fwd_int_in=$tmpd/fwd.int_in.fastq
    rev_int_in=$tmpd/rev.int_in.fastq
    mkfifo "$fwd_int_in" "$rev_int_in"
    # shellcheck disable=SC2094
    tee "./$(basename "$fwd_scythe_out")" < "$fwd_scythe_out" > "$fwd_int_in" &
    # shellcheck disable=SC2094
    tee "./$(basename "$rev_scythe_out")" < "$rev_scythe_out" > "$rev_int_in" &
else
    fwd_int_in=$fwd_scythe_out
    rev_int_in=$rev_scythe_out
fi
sickle_in=$tmpd/int$base.fastq
mkfifo "$sickle_in"
python3 -m omics.interleave "${V[@]}" "$fwd_int_in" "$rev_int_in" > "$sickle_in" &
info1 "Start quality score trimming..."
oldbase=$base
base="${base}.sickle"
sickle_out=$tmpd/int$base.fastq
mkfifo "$sickle_out"
sickle pe -t sanger -c "$sickle_in" -M "$sickle_out" &
# $KEEPALL || rm -f -- "int$oldbase.fastq"

oldbase=$base
base=".$FINAL"

if $INTERLEAVE_FASTA; then
    info1 "Start converting to fasta..."
    # copy sickle_out
    sickle_out_orig=$sickle_out
    sickle_out=$sickle_out.copy
    q2a_in=$tmpd/q2a_in
    mkfifo "$sickle_out" "$q2a_in"
    tee "$q2a_in" < "$sickle_out_orig" > "$sickle_out" &
    python3 -m omics.fastq2fasta "${V[@]}" < "$q2a_in" > "int$base.fasta" &
fi

info1 "Separating read directions again..."
fwd_sep_out=$tmpd/$fwd$oldbase.fastq
rev_sep_out=$tmpd/$rev$oldbase.fastq
sep_in=$tmpd/sep_in
int_final=int$base.fastq
mkfifo "$fwd_sep_out" "$rev_sep_out" "$sep_in"
tee "$sep_in" < "$sickle_out" > "$int_final" &
separate-interleaved "${V[@]}" -f "$fwd_sep_out" -r "$rev_sep_out" "$sep_in" &

# copy separate output 
fwd_final=$fwd$base.fastq
rev_final=$rev$base.fastq
fwd_fastqc_2_in=$tmpd/fqc/$fwd$base.fastq
rev_fastqc_2_in=$tmpd/fqc/$rev$base.fastq
mkfifo "$fwd_fastqc_2_in" "$rev_fastqc_2_in"
tee "$fwd_fastqc_2_in" < "$fwd_sep_out" > "$fwd_final" &
tee "$rev_fastqc_2_in" < "$rev_sep_out" > "$rev_final" &
info1 "Starting post-QC fastqc run..."
fastqc -o FASTQC -f fastq -t 2 "$fwd_fastqc_2_in" "$rev_fastqc_2_in" &>> FASTQC/fastqc.log &
#wait %fastqc
#$INTERLEAVE_FASTA && wait %python3
#$KEEPALL || rm -f -- "$fwd$oldbase.fastq" "$rev$oldbase.fastq"
$KEEPALL || clean_intermediates

# map cmd-line sub-strings to job description
declare -A wait_list
wait_list=(
[ fastqc ]="FASTQC"
[omics.derep]="dereplication"
[ scythe ]="adapter trimming"
[omics.interleave]="interleaving"
[ sickle ]="quality trimming"
[omics.fastq2fasta]="converting to fasta format"
[separate-interleave]="separating read directions again"
)

# map PIDs to job wait list
declare -A pids
while read -r line; do
    pid=$(echo "$line" | sed -r 's/[ ]+/ /g' | cut -d' ' -f2)
    for i in "${!wait_list[@]}"; do
        if echo "$line" | grep -q "$i"; then
            pids["$pid"]="$i"
            break
        fi
    done
done < <(jobs -l)

# wait for jobs to finish
for p in $(echo "${!pids[@]}" | sed -r 's/ /\n/g' | sort -n); do
    if wait "$p"; then
       info1 "Done: ${wait_list[${pids[$p]}]}"
   else
       error "${wait_list[${pids[$p]}]}: exit status $?, PID: $pid"
   fi
done

info1 "All done!"


# gmb: input: fwd.fastq
# gmb: input: rev.fastq
# gmb: output: good_int.fasta
# gmb: cpus: 2
