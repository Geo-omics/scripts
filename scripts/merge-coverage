#!/usr/bin/env python3
"""
Make a table of coverage per contig per sample suitable for input to CONCOCT
"""
import argparse
from collections import OrderedDict
from itertools import groupby
from pathlib import Path
import sys


def read_tsv(file):
    """
    Generate list of list from tab-separated data.

    :param iterable file: Iterable of lines of tab-separated data
    """
    for line in file:
        yield line.strip().split('\t')


def main(assembly, outfile, *inputfiles, with_length=False):
    header = ['contig']
    if with_length:
        header.append('length')

    if assembly is None:
        raise RuntimeError('Please provide the assembly, assembly-less '
                           'algorithm is not implemented')

    with assembly.open() as inf:
        # get contigs from assembly
        contigs = sorted([
            line.strip().lstrip('>').split()[0]
            for line in inf
            if line.startswith('>')
        ])

    out_data = OrderedDict([
        (i, {'length': None, 'means': []})
        for i in contigs
    ])

    for i in inputfiles:
        with i.open() as inf:
            # check header
            head = inf.readline().strip().split('\t')
            if not head == ['Contig', 'Depth', 'bases_with_depth',
                            'contigLen', 'fraction_bases_with_depth']:
                raise RuntimeError('Unexpected header found in {}'
                                   ''.format(i.name))

            header.append(i.parts[0])

            in_data = {
                    contig: list(it)
                    for contig, it in groupby(
                        sorted(read_tsv(inf), key=lambda x: x[0]),
                        lambda x: x[0]
                    )
            }

        for contig in out_data:
            if contig in in_data:
                cov_bases = 0
                for line in in_data[contig]:

                    # sanity check
                    if len(line) != 5:
                        raise RuntimeError(
                            'Wrong number of items in line: {}, file: {}'
                            ''.format(line, inf.name)
                        )

                    # more sanity checks
                    try:
                        this_length = int(line[3])
                    except ValueError as e:
                        raise RuntimeError(
                            'Failed to parse length field, not a number?: '
                            'line: {}, file: {}'.format(line, i)
                        )

                    if out_data[contig]['length'] is None:
                        # set length for contig
                        out_data[contig]['length'] = this_length
                    else:
                        if this_length != out_data[contig]['length']:
                            raise RuntimeError(
                                'Unexpected contig length found: {}\nwhole '
                                'line: {}\nfile: {}'
                                ''.format(line[3], line, i)
                            )

                    try:
                        cov_bases += int(line[1]) * int(line[2])
                    except ValueError as e:
                        raise RuntimeError(
                            'Field contents is not a number: line: {}, file: '
                            '{}'.format(line, i)
                        )

                # add mean coverage
                out_data[contig]['means'].append(cov_bases / this_length)
            else:
                out_data[contig]['means'].append(0.0)

    if len(header[2:]) != len(set(header[2:])):
        raise RuntimeError('Ambiguous sample identifiers: {}'
                           ''.format(header[2:]))

    print(*header, sep='\t', file=outfile)
    for contig in out_data:
        out_line = [contig]
        if with_length:
            out_line.append(out_data[contig]['length'] or 0)
        out_line += ['{:.6f}'.format(i) for i in out_data[contig]['means']]
        print(*out_line, sep='\t', file=outfile)


if __name__ == '__main__':
    argp = argparse.ArgumentParser(description=__doc__)
    argp.add_argument(
        '-a', '--assembly',
        metavar='FILE',
        nargs='?',
        default=None,
        help='The assembly file.  This is to be compatible with the CONCOCT '
             'workflow.  If used then contigs not covered by any sample will '
             'appear in the output with zeros (unlike the output of bedtool\'s'
             ' genomeCoverageBed.)'
    )
    argp.add_argument(
        'inputfiles',
        metavar='FILE',
        nargs='+',
        help='List of input coverage files.  Files should be in different '
             'directories.  The first component of each path is taken to '
             'identify the sample.'
    )
    argp.add_argument(
        '-o', '--out',
        metavar='FILE',
        nargs='?',
        type=argparse.FileType('w'),
        default=sys.stdout,
        help='Output file. By default stdout is used.'
    )
    argp.add_argument(
        '--debug',
        action='store_true',
        help='Print stack trace on errors.'
    )
    argp.add_argument(
        '--length',
        action='store_true',
        help='Insert column with contig length. The default is not to insert '
             'lengths.'
    )
    args = argp.parse_args()

    try:
        if args.length:
            print('WARNING: using assembly file, length of not covered contigs'
                  ' is not shown correctly. (implementation missing)',
                  file=sys.stderr)
        main(
            Path(args.assembly),
            args.out,
            *[Path(i) for i in args.inputfiles],
            with_length=args.length
        )
    except Exception as e:
        if args.debug:
            raise
        else:
            print(
                'An error occurred: {}: {}'.format(e.__class__.__name__, e),
                file=sys.stderr,
            )
            sys.exit(1)
